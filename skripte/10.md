# TestNG & Selenium

## TestNG

Koristan materijal:
* [TestNG documentation][testng docs]

---

Pronađeno je puno nedostataka u JUnit-u.

TestNG bogatiji sa mogućnostima u odnosu na JUnit.

**Lako se integriše** sa nekim alatima kao što je Jenkins.

Jedna od glavnih prednosti jeste mogućnost korišćenja **paralelizacije**. 
To nam omogućava da se testovi izvrše brže.

Mogu prosleđivati podaci koji se nalaze izvan testova pomoću 
**konfiguracionih fajlova**. Preko njih možemo i da definišemo koji će 
testovi izvršavati, a koji ne.

Ono što je još njegova prednost jeste mogućnost generisanja specijalizovanih izveštaja.

TestNG dodajemo u `pom.xml` kao dependency. 

Osim njega, dodajemo i dependency za logger pošto bi bez njega dolazilo do upozorenja i grešaka.

---

Test metoda:
```Java
public class StudentTest {
	@Test
	public void kreirajStudenta() {
		// ...
	}
}
```

Umesto korišćenja printova u testu, praktičnije je da se iskoristi loger.
Ispis pomoću logera možemo izvršiti sa `logger.info("Poruka")`.

Instancu logera možemo da kreiramo pomoću factory-a iz zavisnosti koju smo uključili, 
tj. `LoggerFactory` iz `org.slf4j`.

Kreiranje logera:
```Java
// ...
import org.slf4j.Logger;          // obrati pažnju na ovo jer postoji Logger i u nekom drugom paketu
import org.slf4j.LoggerFactory;
// ...

public class StudentTest {
	private static Logger logger = LoggerFactory.getLogger(Logger.class);
	
	// ...
	
	@Test
	public void kreirajStudenta() {
		Student student = new Student("Petar", 1, 2023, 4);
		System.out.println("Ime studenta je: " + student.ime);
		logger.info("Ime studenta je: " + student.ime);
		assertNotNull(student);
	}
	
	// ...
}
```

Možemo i definisati metode koje će biti izvršene pre i/ili posle svakog testa 
(metode koja je označena sa anotacijom `@Test`) pomoću anotacija `@BeforeMethod` 
i `@AfterMethod`. 

Pored tih anotacija, postoji i anotacija `@BeforeClass` koja se postavlja
nad metodom koja će se pozvati **pre nego što se pozove prva testna metoda**. 

Analogno toj anotaciji, postoji i anotacija `@AfterClass` koja se poziva **nakon što su
svi testni metodi izvršeni**.


Ono što je bitno imati u vidu jeste to da je test u TestNG-u **širi pojam** u odnosu na JUnit.
Ne odnosi se na jedan metod, što se u TestNG-u naziva testnim metodom, već na skup testnih
klasa.

Imamo anotacije i za te testove, `@BeforeTest` i `@AfterTest`. Prvom se označava da će 
se metod izvršiti pre nego što se izvrši bilo koja testna metoda iz datog testa (tj. testnih 
klasa koje mu pripadaju).

```Java
public class StudentTest {

    private static Logger logger = LoggerFactory.getLogger(Logger.class);

    Student student;
	
    @BeforeTest
    public void preTesta() {
        logger.info("pre testa");
    }

    @AfterTest
    public void posleTesta() {
		logger.info("nakon testa");
    }
	
    @BeforeClass
    public void preKlase() {
        logger.info("pre svih testnih metoda testne klase");
    }

    @AfterClass
    public void posleKlase() {
		logger.info("nakon svih testnih metoda testne klase");
    }
	
    @BeforeMethod
    public void setUp() {
        logger.info("pre test metode");
    }

    @AfterMethod
    public void tearDown() {
		logger.info("nakon test metode");
    }

    @Test
    public void demo1(){
        logger.info("demo1 test");
        assertEquals(10, 10);
    }
	
    @Test
    public void demo2(){
        logger.info("demo 2 - failed");
        assertEquals(10, 1);
    }
}
```

Svi testovi su deo nekog suite-a. Podrazumevani je "Default Suite". Biće više reči o njemu kasnije. 

U TestNG-u postoji i konfiguracija u vidu xml fajla. U njoj možemo npr. definisati koje testne klase
testa želimo da testiramo. Klase koje nismo označili za izvršavanje će biti ignorisane.

Ono što je još bitno kod konfiguracije jeste **parametrizacija testova**.

---

U `test > java` možemo da kreiramo taj konfiguracioni xml fajl. Dobra strana korišćenja xml-a je to 
što se lako menja i tumači, a pre svega to što nakon tih promena mi ne moramo ponovo da kompajliramo
kod što nam olakšava pokretanje testova.

Taj fajl sadrži određenu šemu pa je potrebno na njegovom početnu definisati definiciju tipa dokumenta.
Nakon definisanja tipa dokumenta, možemo koristiti tagove koje TestNG definiše.

Jedan od njih je `<suite>` kojim se definiše suite i ima **obavezni** atribut `name` koji predstavlja
naziv suite-a. 

Unutar njega definišemo testove pomoću taga `<test>` koji ima atribut `name`, a unutar tih testova
niz testnih klasa koje će biti izvršene. Niz se definiše sa tagom `<classes>`, a unutar njega testne klase 
sa tagom `<class>`. Tag za testne klase takođe sadrži atribut `name` i u njemu se definiše **cela putanja**
do date klase.

Unutar taga za testnu klasu možemo da definišemo koje metode želimo da ignorišemo ili samo metode koje
želimo da izvršimo. To radimo unutar taga `<methods>` koji se nalazi u tagu `<class>`. One metode koje nisu 
navedene će biti primenjena **suprotna** akcija. Ako definišemo metode koje ćemo ignorisati, onda će sve druge 
metode biti izvršene, a ako definišemo metode koje želimo da se izvrše, onda će sve druge metode biti ignorisane.

Metode koje jedino **želimo da izvršimo** se definišu tako što se njihovo ime navede u atributu `name` taga `<include>`,
dok se u slučaju **isključivanja (ignorisanja)** koristi tag `<exclude>`.

**Testove pokrećemo biranjem opcije "Run" iz menija koji dobijamo desnim klikom na konfiguracioni fajl.**

Primer konfiguracionog (XML) fajla:
```XML
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >

<suite name="Naziv Suite-a">

    <test name="osnovni testovi"   >
        <classes>
            <class name="pmf.imi.StudentTest" />
            <class name="pmf.imi.SaradnikTest">
                <methods>
                    <exclude name="primer4" />
                    <exclude name="primer5" />
                </methods>
            </class>
        </classes>
    </test>

    <test name="neki drugi testovi">
        <classes>
            <class name="pmf.imi.ProfesorTest"></class>
        </classes>
    </test>

</suite>
```

### Parametri

Parametre definišemo u anotaciji `@Parameters`. Prosleđuju se tako što se unutar vitičastih zagrada 
navedu stringovi koji predstavljaju nazive parametara koji su definisani u konfiguracionom fajlu.
Tag za parametar je `<parameter>` i sadrži atribute `name` i `value`.

Anotacija i navođenje naziva:
```Java
@Parameters({"param1", "param2", "param3", "param4"})
public void metod(String par1, String nesto2, String par3, String param4) {}
```

Izgled dela konfiguracionog fajla:
```XML
<suite name="Naziv Suite-a">

    ...

    <test name="osnovni testovi"   >
        <parameter name="param1" value="jedan"></parameter>
        <parameter name="param2" value="dva"></parameter>
        <parameter name="param3" value="tri"></parameter>
        <parameter name="param4" value="cetiri"></parameter>
		
	...
		
    </test>
	
    ...
	
</suite>
```

Kao što možemo primetiti, nazivi parametara metoda **ne moraju** da se poklapaju sa nazivima 
parametara testa jer će biti prosleđeni metodu po redosledu u kome su definisani u anotaciji.

[#]: / (Tom metodu možemo proslediti i još neke dodatne parametre nakon ovih koji su definisati.)

U anotaciji navodimo samo one parametre iz konfiguracije koje ćemo proslediti datom metodu 
(ne moraju svi da se navedu). 

**Scope parametara zavisi od toga u kom tagu su definisani**. U prethodnom isečku koda, parametri
su definisani na nivou suite-a.

### Izveštaji

Testovi se mogu izvršavati automatski. Na platformama kao što je GitLab, možemo imati podešen mehanizam
koji će pri svakom merge-u pokrenuti sve testove automatski. Tada je od velikog značaja pregledan i 
jasan izveštaj tog testiranja.

TestNG ima integracije sa svim poznatim sistemima za DevOps kao što je Jenkins. Generisani izveštaji
se mogu videti unutar Jenkins-a.

Izveštaji mogu da se kreiraju i pri pokretnaju nekog testa.

Jedan od izveštaja koji se može kreirati jeste izveštaj u vidu HTML stranice.

U IntelliJ-u, u gornjem desnom uglu kod mesta na kome možemo pokrenuti program biramo "Run Configurations...".
U delu "Configurations" otvorenog prozora imamo više tabova, među kojima je i tab "Listeners". Biramo taj tab 
i dodajemo neki listener na plus. Onaj koji nas zanima jeste neki HTML Reporter. "Reporter" se odnosi na 
klasu kojom menjamo podrazumevani način generisanja izveštaja.

Rezultat će nakon pokretanja biti generisan u folderu `test-output`. U folderu koji se zove kao suite 
će biti generisani HTML fajlovi za svaki test.

## Selenium

Koristan materijal:
* [Selenium Documentation][selenium docs]
* [Guru99 - Selenium Tutorial][selenium guru99]
* [w3schools CSS Selectors][w3s css selectors]

---

Selenium simulira interakciju korisnika sa web browser-om. Može da otvori web browser,
simulira klik, pronađe element na stranici, da popuni polje i tako dalje.

To se postiže tako što se pomoću Web Driver-a iz koda kreira i kontroliše instanca web 
browser-a.

Za svaki web browser postoji poseban Web Driver. 

Postoje opcije:
* Firefox
* Edge
* Chrome (na Linux-u Chromium)

Imamo 2 opcije za uključivanje Web Driver-a u projekat:
1. dodavanje Web Driver-a za određeni web browser kao zavisnosti projekta
2. dodavanje Web Driver-a automatski pomoću određene zavisnosti (**zahteva internet konekciju**)

---

Kako bismo koristili Selenium u svom projektu, neophodno je da kreiramo instancu Web Driver-a.
Obično se u testnoj klasi definiše polje tipa `WebDriver` koje će referencirati instancu Web Driver-a

Instanciranje se najčešće odvija u 2 koraka, odnosno u 2 metode:
1. učitavanje web menadžera u `@BeforeSuite` metodi (metodi koja će biti izvršena pre svih drugih metoda)
2. instanciranje Web Driver-a u `@BeforeMethod`, kako bi se napravio novi pre svakog testa

Primer:
```Java
public class DemoTest {
	private static Logger logger = LoggerFactory.getLogger(Logger.class);

	WebDriver driver;

	@BeforeSuite
	public void beforeSuite() {
		WebDriverManager.edgedriver().setup();
	}
	
	@BeforeMethod
	public void beforeMethod() {
		driver = new EdgeDriver();
	}
	
	@Test
	public void navigateToWebAdress() {
		String url = "https://imioer.github.io/kts/";
		
		driver.get(url);
		String currentUrl = driver.getCurrentUrl();
		
		logger.info(currentUrl);
		logger.info(driver.getTitle());
		
		assertEquals(currentUrl, url);
	}
}
```

Instanca `WebDriver`-a ima više nekih metoda pomoću kojih možemo da interagujemo
sa stranicom, kao i metoda pomoću kojih možemo doći do nekih informacija.

Sa `driver.getCurrentUrl()` dolazimo do trenutne URL adrese, a preko
`driver.getTitle()` možemo dobiti title trenutne stranice.

Nakon build-a projekta, dolazi kreira instanca Edge-a i njegovom otvaranja.

Kada se sve učita, test se dalje nastavlja i vriši se validacija trenutnog
URL-a.

Treba primetiti da nakon obavljenog testa web browser još uvek ostaje
otvoren. Ukoliko bismo pokrenuli test još nekoliko puta, imali bismo
više aktivnih instanci browser-a. 

Da bismo ovo sprečili, gasimo kreirani web browser nakon svakog izvršenog
testnog metoda:
```Java
@AfterMethod
public void afterTestMethod() {
	driver.quit();
}
```

---

Spomenuli smo da pomoću Seleniuma možemo vršiti i kompleksnije operacije kao 
što je unos u neko polje i klik na dugme.

Da bismo to odradili, potrebno je da se pronađu odgovarajući elementi, a to 
radimo pomoću lokatora.

Postoji više tipova lokatora, tj. strategija lociranja elemenata.

Osnovna klasa u procesu lociranja elementa je klasa `By`. Pomoću njenih statičnih
metoda se definiše **uslov** pretrage. Ono što ti metodi rade jeste samo definisanje 
uslova, a to **ne uključuje i pronalaženje** datog elementa. Da bismo pronašli element,
dati uslov prosleđujemo dalje Web Driver-u preko njegovih metoda `findElement` i 
`findElements`. Odabir neke od te 2 metode zavisi od toga broja elemenata koji 
očekujemo. Rezultat je instanca klase `WebElement`.

**Pri lociranju elementa, bitno je da rezultat bude jedinstven.** Ako ih ima više, prvi 
će biti izabran. Zbog toga, kada analiziramo stranicu, trudimo se da biramo ono
što dati element jedinstveno identifikuje. Ako ne možemo direktno da ga identifikujem,
onda ga identifikujemo indirektno preko drugih elemenata koje možemo direktno identifikovati.
To uglavnom radimo definisanjem detaljnijih opisa kojima se opisuje gde se dati element nalazi
u odnosu na onaj element do koga možemo lako doći.

Elementu možemo proslediti string pomoću metode `sendKeys`. Time se samo unosi
nešto u taj element, tj. polje koje on predstavlja. 

Dodatno je potrebno i submit-ovati unos pomoću `submit` metode elementa. To možemo
odraditi i slanjem novog reda.

Submit nas vodi na novu stranicu pa je poželjno utvrditi i da li je došlo do prelaska
na odgovarajuću stranicu.

Primer:
```Java
@Test
public void testSearchPattern(){
	driver.get("https://www.tehnomedia.rs/");

	By elementSearchBy = By.id("search-text");
	WebElement input = driver.findElement(elementSearchBy);

	input.sendKeys("monitor");
	input.submit();

	assertTrue(driver.getCurrentUrl().endsWith("/search/find.html?rec=monitor"));
}
```

Pri validaciji rezultata **poželjno je da se proveri da li rezultat pretrage nije `null`**.

---

Ukoliko sada želimo da testiramo stranicu koja predstavlja rezultat pretrage, ne moramo ponovo 
vršimo akcije koje dovode do tog rezultata, već **možemo da iskoristimo adresu (URL) tog rezultata**, 
tj. `https://www.tehnomedia.rs/search/find.html?rec=monitor` iz prethodnog primera, i početi rad od te adrese. 
U prethodnom primeru to možemo da odradimo jer URL sadrži query deo koji nam daje dati rezultat, 
ali to **ne možemo uvek raditi** jer neke stranice ne šalju upit serveru za neke rezultate preko URL, već
to možda rade preko tela zahteva.

---

Ukoliko koristimo `driver.findElements(uslov)`, očekujemo kao rezultat list 
elemenata, tj. `List<WebElement>`. Dobijeni rezultat možemo da testiramo tako 
što bismo proverili da li smo dobili očekivani broj elemenata i to radimo 
poređenjem očekivanog broja sa brojem elemenata dobijene liste.

---

Za uslova za lociranje elemenata sem `By.id` možemo koristiti i:
* `By.name` - `name` atribut tag-a
* `By.className` - klasa taga (vrednost `class` atribut tag-a)
* `By.tagName` - ime tag-a
* `By.linkText` - tekst linka (tekst koji predstavlja link na stranici)
* `By.partialLinkText` - deo tekst linka (teksta koji predstavlja link na stranici)
* `By.cssSelector`
* `By.xpath`

---

Neki CSS selektori:
* `#identifikator` - tag čiji atribut `id` ima vrednost `identifikator`
* `.klasa` - tag čiji atribut `class` ima vrednost `klasa`
* `tag1 tag2` - selektovanje svih `tag2` unutar `tag1` (bilo gde u njegovoj hijerarhiji)
* `tag1, tag2` - selektovanje svih `tag1` i `tag2` (posmatra ih nezavisno)
* `tag1 > tag2` - selektovanje svih `tag2` koji se direktno nalaze unutar `tag1` (direktni potomci, a ne potomci potomaka)
* `tag.klasa` - selektovanje tagova `tag` koji imaju vrednost `klasa` za atribut `class`

Možemo ih i kombinovati, npr. `tag1.klasa > tag2` čime selektujemo sve `tag2` koji se nalaze
direktno unutar nekog `tag1` taga koji ima atribut `class` setovan na `klasa`.



[#]: / (---------------------------------------------------------)

[testng docs]: https://testng.org/doc/documentation-main.html

[selenium docs]: https://www.selenium.dev/documentation/overview/
[selenium guru99]: https://www.guru99.com/selenium-tutorial.html
[w3s css selectors]: https://www.w3schools.com/cssref/css_selectors.php